# Haskell Projects (by surafel)
### Reverse Polish Notation Evaluator

A command line program that calculates a reverse polish notaion math problem.
it does not validate the notaion so try to enter a valid notation.
this program is not an end product as it produces an error for more complicated inputs. it will be updated once solved.
- the error: "Exception: Prelude.tail: empty list"
- example input: "10 6 9 3 + -11 * / * 17 + 5 +"

### Folding Exercises

A series of Prelude functions defined using the fold functions, contains functions like length, ++, product, or, any, all, map, reverse, concat and many more to come.

### Exercism Exercises

Solved exercises form https://exercism.org/.

### Map Exercises

a set of exercises generated by chatGPT to practice maps. The generated
answer goes like this.

Certainly! Here are some exercises to practice working with Haskell maps:

1) Write a function 'getMaxValue' that takes a map with integer values and returns the maximum value in the map.
    eg. Input: { "a" -> 10, "b" -> 5, "c" -> 15 }
        Output: 15

2) Write a function 'convertToMap' that takes a list of tuples and converts it into a map, where the first element of each tuple is the key and the second element is the value.
    eg. Input: [(1,"a"), (2,"b"), (3,"c")]
        Output: { 1 -> "a", 2 -> "b", 3 -> "c" }

3) Write a function 'filterByValue' that takes a map and a predicate function, and returns a new map with only the key-value pairs that satisfy the predicate.
    eg. Input: { "a" -> 10, "b" -> 5, "c" -> 15 } and (\v -> v > 8)
        Output: { "a" -> 10, "c" -> 15 }

4) Write a function 'sortByValue' that takes a map with integer values and returns a list of the keys sorted by their values in descending order.
    eg. Input: { "a" -> 10, "b" -> 5, "c" -> 15 }
        Output: ["c", "a", "b"]

5) Write a function 'updateValue' that takes a map, a key, and a function that operates on the value associated with the key. The function should update the map with the new value returned by the function.
    eg. Input: { "a" -> 10, "b" -> 5, "c" -> 15 }, "b", and (+5)
        Output: { "a" -> 10, "b" -> 10, "c" -> 15 }

6) Write a function 'combineMaps' that takes two maps with integer values and returns a new map where the keys are the union of the keys from the input maps, and the values are the sum of the corresponding values in the input maps.
    eg. Input: { "a" -> 10, "b" -> 5, "c" -> 15 } and { "a" -> 5, "d" -> 10 }
        Output: { "a" -> 15, "b" -> 5, "c" -> 15, "d" -> 10 }

7) Write a function 'reverseMap' that takes a map and returns a new map with the keys and values reversed.
    eg. Input: { "a" -> 10, "b" -> 5, "c" -> 15 }
        Output: { 10 -> "a", 5 -> "b", 15 -> "c" }

8) Write a function mapKeys that takes a function and a map, and returns a new map with the same values as the input map, but with the keys transformed by the input function. For example:
    eg. Input: (\k -> k ++ "x"), { "a" -> 1, "b" -> 2, "c" -> 3 }
        Output: { "ax" -> 1, "bx" -> 2, "cx" -> 3 }

9) Write a function mapValues that takes a function and a map, and returns a new map with the same keys as the input map, but with the values transformed by the input function. For example:
    eg. Input: (\v -> v * 2), { "a" -> 1, "b" -> 2, "c" -> 3 }
        Output: { "a" -> 2, "b" -> 4, "c" -> 6 }

10) Write a function zipKeysAndValues that takes two lists of equal length and returns a map where the elements of the first list are the keys and the elements of the second list are the values. For example:
    eg. Input: ["a", "b", "c"], [1, 2, 3]
        Output: { "a" -> 1, "b" -> 2, "c" -> 3 }

11) Write a function unzipKeysAndValues that takes a map and returns a tuple of two lists, where the first list contains the keys and the second list contains the values. For example:
    eg. Input: { "a" -> 1, "b" -> 2, "c" -> 3 }
        Output: (["a", "b", "c"], [1, 2, 3])

12) Write a function mapToList that takes a map and returns a list of tuples where each tuple contains a key-value pair from the map. For example:
    eg. Input: { "a" -> 1, "b" -> 2, "c" -> 3 }
        Output: [("a", 1), ("b", 2), ("c", 3)]

I hope these exercises help you become more proficient in working with Haskell maps!